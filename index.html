<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>マイマジョ</title>
<style>
html, body{ height:100%; overflow:hidden; }
body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}

header{
  display:flex; justify-content:space-between; align-items:center;
  padding:10px 12px; border-bottom:1px solid #eee;
  position:sticky; top:0; z-index:400; background:#fff;
}
h1{margin:0;font-size:18px;}
.small{font-size:12px;opacity:.75;}

main{
  position:relative;
  height:calc(100vh - 60px);
  overflow:auto;
  -webkit-overflow-scrolling:touch;

  /* ★ 入室前：トップ画像 */
  background-image: url('mymajotop.jpg');
  background-repeat: no-repeat;
  background-position: center;
  background-size: cover;
}
/* 入室後：背景差し替え */
main.entered{
  background-image: url('majoback.jpg');
  background-repeat: no-repeat;
  background-position: center;
  background-size: cover;
}

.join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px;}
.join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
.btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
.btn.primary{background:#111;color:#fff;border-color:#111;}
.btn.ghost{ background:#111;color:#fff;border-color:#111; }
.hidden{display:none;}
#lobby{padding:20px;border-top:1px solid #eee;}
.copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

.seat-pop{position:fixed;left:50%;bottom:10px;transform:translateX(-50%);background:orange;border:1px solid #eee;border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.12);padding:10px;z-index:220;display:flex;flex-direction:column;gap:10px;min-width:280px;}
.seat-pop.hidden{display:none;}
.seat-pop .row{display:flex;gap:8px;align-items:center;}
.seat-pop label{width:84px;font-size:13px;}
.seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
.tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
.tab.disabled{opacity:.35;pointer-events:none;}
.tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
.tab.active{background:#111;color:#fff;border-color:#111;}

/* ★ 下黒ポップ（ホスト人数選択中） */
.status-pop{
  position:fixed;
  left:50%;
  bottom:12px;
  transform:translateX(-50%);
  background:rgba(0,0,0,.92);
  color:#fff;
  border-radius:999px;
  padding:10px 14px;
  font-weight:900;
  font-size:13px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  z-index:270;
  white-space:nowrap;
}
.status-pop.hidden{display:none;}

.player-circle{
  position:relative;
  width:320px; height:320px;
  margin:20px auto 0;
  border-radius:50%;
  border:none;
  box-sizing:border-box;
}
.player-circle::before{ content:''; }

.player-tag{
  position:absolute;
  transform:translate(-50%,-50%);
  padding:4px 8px;
  border-radius:999px;
  background:#f8f8f8;
  border:1px solid #ddd;
  font-size:12px;
  white-space:nowrap;
  user-select:none;
}
.player-tag.me{ background:#111; color:#fff; border-color:#111; }
.player-tag.voted:not(.me){ background:#111; color:#fff; border-color:#111; }
.player-tag.votable:hover{ outline:2px solid rgba(0,0,0,.18); outline-offset:2px; }
.player-tag.unvotable{opacity:.45;filter:saturate(.6);cursor:not-allowed !important;pointer-events:none;}

.vote-badge{
  position:absolute; left:50%; top:-16px;
  transform:translateX(-50%);
  font-size:14px; line-height:1;
  pointer-events:none;
  filter: drop-shadow(0 2px 6px rgba(0,0,0,.25));
  color:#111;
}

.player-tag .mini-role{
  position:absolute; left:50%; top:100%;
  transform:translate(-50%,3px);
  width:18px; height:24px;
  pointer-events:none;
}
.player-tag.done .mini-role{
  left:-60%;
  top:100%;
  transform:translate(-50%,3px);
}
.player-tag .mini-card{
  position:absolute;
  left:50%; top:0;
  width:16px; height:22px;
  border-radius:4px;
  border:1px solid #bbb;
  transform:translate(-50%,0);
  box-shadow:0 2px 6px rgba(0,0,0,.15);
  background-repeat:no-repeat;
  background-position:center;
  background-size:120%;
  background-color:#fff;
}
.player-tag .mini-card.role-revealed{
  border-color:#fff !important;
  background-color:#fff !important;
  display:block;
  transform: translate(-50%,0) scale(1.5);
  transform-origin: 50% 0%;
  z-index: 3;
}

.player-tag .mini-pboard{
  position:absolute;
  left:50%;
  top:100%;
  transform:translate(-50%,30px);
  width:73px;
  height:52px;
  box-sizing:border-box;
  border-radius:5px;
  border:2px solid #111;
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  background:#a16207;
  pointer-events:none;
  overflow:hidden;
}
.player-tag .mini-pboard.revealed{ background:#fff; }
.player-tag.done .mini-pboard{ transform:translate(-50%,3px); }
.mini-pboard-canvas{ width:100%; height:100%; display:block; }

.whiteboard{ position:absolute; }
.whiteboard::after{
  content:'今回のお題';
  position:absolute;
  top:-10px; left:50%;
  transform: translateX(-50%) rotate(-5deg);
  font-size:14px; font-weight:900; color:#fff;
  background:#a16207;
  padding:2px 8px;
  border-radius:6px;
  pointer-events:none;
  white-space:nowrap;
  box-shadow:0 2px 6px rgba(0,0,0,.25);
}

.my-hand-wrapper{ margin-top:16px; text-align:center; }
.my-hand-title{display:none;}
.my-hand{
  display:flex;
  justify-content:center;
  gap:10px;
  margin-top:6px;
  min-height:110px;
  align-items:flex-start;
}
.my-card{
  width:60px; height:90px;
  border-radius:8px;
  border:1px solid #ddd;
  background:#fff;
  box-shadow:0 4px 12px rgba(0,0,0,.15);
  user-select:none;
  background-repeat:no-repeat;
  background-position:center;
  background-size:contain;
  padding:0;
}

.pboard{
  position:relative;
  width:160px;
  height:110px;
  background:#fff;
  border:2px solid #111;
  border-radius:8px;
  box-shadow:0 10px 22px rgba(0,0,0,.18);
  padding:10px;
  box-sizing:border-box;
  cursor:pointer;
  overflow:hidden;
}
.pboard.flipped{ background:#a16207; cursor:pointer; }
.pboard .pboard-hint{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
  font-weight:800;
  font-size:14px;
  opacity:.35;
  pointer-events:none;
  padding:6px;
}
.pboard .pboard-preview{ position:absolute; inset:10px; border-radius:6px; overflow:hidden; }
.pboard .pboard-preview canvas{ width:100%; height:100%; display:block; }
.pboard.flipped .pboard-preview{ display:none; }
.pboard.flipped .pboard-hint{ display:none; }
.pboard-done{ display:none !important; }

.dialog-backdrop{
  position:fixed; inset:0;
  background:rgba(0,0,0,.35);
  display:flex; align-items:center; justify-content:center;
  z-index:300;
}
.dialog-backdrop.hidden{display:none;}
.dialog-box{
  background:#fff;
  border-radius:12px;
  padding:16px 18px;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  max-width:320px;
  width:calc(100% - 40px);
}
.dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
.dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

.host-settings-btn{
  position:fixed;
  right:16px;
  bottom:16px;
  width:44px;
  height:44px;
  border-radius:50%;
  border:1px solid #ddd;
  background:#fff;
  box-shadow:0 8px 20px rgba(0,0,0,.18);
  display:none;
  align-items:center;
  justify-content:center;
  font-size:22px;
  cursor:pointer;
  z-index:230;
}
.host-settings-btn.visible{display:flex;}

.start-pop{
  position:fixed;
  right:16px;
  bottom:72px;
  background:#fff;
  border:1px solid #ddd;
  border-radius:12px;
  box-shadow:0 12px 28px rgba(0,0,0,.16);
  padding:10px 12px;
  z-index:240;
  min-width:240px;
  display:flex;
  flex-direction:column;
  gap:8px;
}
.start-pop.hidden{display:none;}
.start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
.start-pop-title{font-size:14px;font-weight:900;}
.start-pop-main{font-size:13px;line-height:1.5;}
.start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;}
.start-pop-actions .btn{font-weight:900;}

#roomInfoLobby,#lobby h2,#lobby p{display:none;}
#lobby.entered{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  min-height:calc(100vh - 60px);
}

.whiteboard{
  position:absolute;
  left:50%;
  top:60%;
  transform:translate(-50%,-50%);
  width:160px;
  height:110px;
  background:#fff;
  border:2px double #7dd3fc;
  border-radius:5px;
  box-shadow:0 10px 22px rgba(0,0,0,.18);
  padding:10px;
  box-sizing:border-box;
  z-index:5;
}
.whiteboard-inner{
  width:100%;
  height:100%;
  overflow:hidden;
  outline:none;
  font-weight:700;
  line-height:1.18;
  white-space:pre-wrap;
  word-break:break-word;
  user-select:text;
  display:flex;
  align-items:center;
  justify-content:center;
  text-align:center;
}
.whiteboard-inner[data-placeholder]:empty::before{ content:attr(data-placeholder); opacity:.35; }

.best-btn{
  position:fixed;
  left:50%;
  bottom:14px;
  transform:translateX(-50%);
  width:120px;
  height:120px;
  border-radius:50%;
  border:3px solid #111;
  background:#fff;
  box-shadow:0 14px 34px rgba(0,0,0,.22);
  z-index:260;
  display:none;
  align-items:center;
  justify-content:center;
  padding:16px;
  cursor:pointer;
  user-select:none;
  text-align:center;
  font-weight:900;
  line-height:1.1;
  font-size: 18px;
}
.best-btn.visible{ display:flex; }
.best-btn small{ display:block; font-size:12px; opacity:.8; margin-top:6px; }

.pboard.selected{ background:#2563eb !important; border-color:#0b1b3a !important; }
.player-tag .mini-pboard.selectable{ pointer-events:auto; cursor:pointer; }
.player-tag .mini-pboard.selected{ background:#2563eb !important; border-color:#0b1b3a !important; }

.vote-pop{
  position:fixed;
  left:50%;
  bottom:14px;
  transform:translateX(-50%);
  background:#fff;
  border:1px solid #ddd;
  border-radius:14px;
  box-shadow:0 16px 34px rgba(0,0,0,.2);
  padding:10px 14px;
  z-index:265;
  min-width:280px;
  max-width:420px;
}
.vote-pop.hidden{display:none;}
.vote-pop .title{font-weight:900;font-size:14px;margin-bottom:4px;}
.vote-pop .desc{font-size:13px;line-height:1.45;opacity:.9;}
.vote-pop .desc strong{font-weight:900;}

.help-btn{
  position:fixed;
  left:16px;
  bottom:16px;
  width:44px;
  height:44px;
  border-radius:50%;
  border:1px solid #111;
  background:#111;
  color:#fff;
  box-shadow:0 8px 20px rgba(0,0,0,.18);
  display:none;
  align-items:center;
  justify-content:center;
  font-size:22px;
  font-weight:900;
  cursor:pointer;
  z-index:235;
}
.help-btn.visible{ display:flex; }

.help-backdrop{
  position:fixed; inset:0;
  background:rgba(0,0,0,.35);
  display:flex; align-items:center; justify-content:center;
  z-index:500;
}
.help-backdrop.hidden{ display:none; }

.help-modal{
  width:min(720px, calc(100% - 28px));
  max-height:min(78vh, 640px);
  background:#fff;
  border-radius:14px;
  border:1px solid #e5e7eb;
  box-shadow:0 18px 40px rgba(0,0,0,.35);
  overflow:hidden;
}
.help-modal-header{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:10px 12px;
  border-bottom:1px solid #eee;
}
.help-modal-title{ font-size:14px; font-weight:900; }
.help-close{
  padding:4px 8px;
  border-radius:10px;
  border:1px solid #ddd;
  background:#fff;
  cursor:pointer;
  font-weight:900;
}
.help-modal-body{
  padding:12px;
  overflow:auto;
  max-height:calc(78vh - 52px);
}
.help-list{ display:flex; flex-direction:column; gap:10px; }
.help-row{ display:flex; gap:12px; align-items:flex-start; }
.help-cardimg{
  width:110px;
  height:165px;
  border-radius:10px;
  border:1px solid #e5e7eb;
  background:#fff;
  box-shadow:0 6px 14px rgba(0,0,0,.10);
  background-repeat:no-repeat;
  background-position:center;
  background-size:contain;
  flex:0 0 auto;
  opacity:1;
  transition:opacity .12s ease;
}
.help-cardimg.dim{ opacity:.30; }
.help-cardimg.full{ opacity:1; }
.help-cardimg.clickable{ cursor:pointer; }
.help-desc{
  flex:1 1 auto;
  font-size:13px;
  line-height:1.55;
  color:#111;
  font-weight:650;
  white-space:pre-wrap;
}
@media (max-width: 520px){
  .help-row{ flex-direction:column; }
  .help-cardimg{ width:140px; height:210px; }
}

.draw-backdrop{
  position:fixed; inset:0;
  background:rgba(0,0,0,.42);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:800;
}
.draw-backdrop.hidden{ display:none; }

.draw-panel{
  width:min(560px, calc(100% - 18px));
  background:transparent;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:10px;
}

.draw-board{
  width:100%;
  aspect-ratio: 16 / 10;
  background:#fff;
  border:2px double #7dd3fc;
  border-radius:10px;
  box-shadow:0 18px 44px rgba(0,0,0,.35);
  overflow:hidden;
  position:relative;
}
#drawCanvas{
  width:100%;
  height:100%;
  display:block;
  touch-action:none;
}
.draw-actions{
  width:100%;
  display:flex;
  justify-content:center;
  gap:10px;
}
.draw-actions .btn{
  padding:10px 14px;
  border-radius:999px;
  font-weight:900;
}
.eraser-btn{
  width:73px;
  height:52px;
  padding:0;
  border-radius:999px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  border:1px solid #ddd;
  background-repeat:no-repeat;
  background-position:center;
  background-size:85%;
}
.eraser-btn.is-pen{ background-image:url('pen.png'); }
.eraser-btn.is-eraser{ background-image:url('kesigomu.png'); }

/* ===========================
   ★ 中央拡大カード（揺らし）
   =========================== */
.mv-backdrop{
  position:fixed; inset:0;
  background:rgba(0,0,0,.55);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:900;
}
.mv-backdrop.hidden{ display:none; }
.mv-card{
  width:min(240px, 62vw);
  aspect-ratio: 2 / 3;
  border-radius:16px;
  border:2px solid rgba(255,255,255,.9);
  box-shadow:0 24px 70px rgba(0,0,0,.55);
  background:#fff;
  background-repeat:no-repeat;
  background-position:center;
  background-size:contain;
  transform-origin:50% 55%;
  animation: mvPop .22s ease-out both, mvWobble .9s ease-in-out .22s both;
}
@keyframes mvPop{
  from{ transform: translateY(10px) scale(.86); opacity:.0; }
  to  { transform: translateY(0)   scale(1.0); opacity:1; }
}
@keyframes mvWobble{
  0%{ transform: rotate(0deg) scale(1); }
  15%{ transform: rotate(-5deg) scale(1.02); }
  35%{ transform: rotate(6deg) scale(1.03); }
  55%{ transform: rotate(-4deg) scale(1.02); }
  75%{ transform: rotate(3deg) scale(1.01); }
  100%{ transform: rotate(0deg) scale(1); }
}

/* ===========================
   ★ 追加：ジーザス黒ポップ（クリックで公開）
   =========================== */
.jesus-backdrop{
  position:fixed; inset:0;
  background:rgba(0,0,0,.35);
  display:flex;
  align-items:center;
  justify-content:center;
  z-index:950;
}
.jesus-backdrop.hidden{ display:none; }
.jesus-pop{
  background:rgba(0,0,0,.92);
  color:#fff;
  border-radius:16px;
  padding:18px 22px;
  box-shadow:0 18px 44px rgba(0,0,0,.45);
  max-width:min(420px, calc(100% - 44px));
  text-align:center;
  font-weight:900;
  line-height:1.6;
  cursor:pointer;
  user-select:none;
}
.jesus-pop .smallhint{
  display:block;
  margin-top:10px;
  font-size:12px;
  font-weight:800;
  opacity:.85;
}
</style>
</head>

<body>
<header>
  <h1>マイマジョ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">COPY</button>
  </div>
</header>

<main>
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle">
      <div id="whiteboard" class="whiteboard">
        <div id="wbText" class="whiteboard-inner" data-placeholder="クリックして入力"></div>
      </div>
    </div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<button id="helpBtn" class="help-btn" type="button" aria-label="ヘルプ">？</button>

<div id="helpBackdrop" class="help-backdrop hidden" aria-hidden="true">
  <div class="help-modal" role="dialog" aria-modal="true" aria-label="正体カード説明">
    <div class="help-modal-header">
      <div class="help-modal-title">正体カードの説明（ホストはカード画像をクリックでON/OFF）</div>
      <button id="helpClose" class="help-close" type="button">×</button>
    </div>
    <div class="help-modal-body">
      <div id="helpList" class="help-list"></div>
    </div>
  </div>
</div>

<div id="drawBackdrop" class="draw-backdrop hidden" aria-hidden="true">
  <div class="draw-panel">
    <div class="draw-board">
      <canvas id="drawCanvas"></canvas>
    </div>
    <div class="draw-actions">
      <button id="btnEraser" class="btn eraser-btn" type="button" aria-label="消しゴム切替"></button>
      <button id="btnUndo" class="btn" type="button">やり直す</button>
      <button id="btnDoneDraw" class="btn primary" type="button">完了</button>
    </div>
  </div>
</div>

<button id="bestAnswerBtn" class="best-btn hidden" type="button">
  <div>
    <div id="bestAnswerLabel">No Best Answer!</div>
  </div>
</button>

<div id="votePop" class="vote-pop hidden">
  <div class="title">マイノリティに投票しよう！</div>
  <div class="desc">ネームタグを選択（<strong>全員決定までは選び直し可</strong>）</div>
</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<!-- ★ 下黒ポップ -->
<div id="statusPop" class="status-pop hidden">ホストが人数選択中</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<!-- ★ 設定ポップ（スタート + リセット） -->
<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    準備ができたら「スタート」。<br>
    やり直す場合は「リセット」（席選択からやり直し）
  </div>
  <div class="start-pop-actions">
    <button id="btnRoomReset" class="btn">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<!-- ★中央拡大カード（揺らし） -->
<div id="mvBackdrop" class="mv-backdrop hidden" aria-hidden="true">
  <div id="mvCard" class="mv-card" aria-label="結果カード"></div>
</div>

<!-- ★追加：ジーザス黒ポップ（クリックで公開） -->
<div id="jesusBackdrop" class="jesus-backdrop hidden" aria-hidden="true">
  <div id="jesusPop" class="jesus-pop" role="button" tabindex="0" aria-label="ジーザス公開">
    「Oh...Jusus...!」と言って、ここをクリック
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getDatabase, ref, set, get, update, onValue, runTransaction } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qOQ2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  roles: {},
  whiteboard: { text: "" },
  playerDraw: {},
  boardsRevealed: false,
  bestSelected: {},
  votes: {},
  votesDone: false,
  rolesRevealed: false,
  phase: "WRITE",
  forcedRoles: {},
  publicReveals: {},
  fx: null,
  _lastFxNonce: 0,

  /* ★追加：人数（maxPlayers） */
  maxPlayers: null
};

const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');
const statusPop = document.getElementById('statusPop');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnRoomReset = document.getElementById('btnRoomReset');

const votePop = document.getElementById('votePop');

const wb = document.getElementById('whiteboard');
const wbText = document.getElementById('wbText');

const bestAnswerBtn = document.getElementById('bestAnswerBtn');
const bestAnswerLabel = document.getElementById('bestAnswerLabel');

const drawBackdrop = document.getElementById('drawBackdrop');
const drawCanvas = document.getElementById('drawCanvas');
const btnEraser = document.getElementById('btnEraser');
const btnUndo = document.getElementById('btnUndo');
const btnDoneDraw = document.getElementById('btnDoneDraw');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const helpClose = document.getElementById('helpClose');
const helpList = document.getElementById('helpList');

/* ★中央拡大カード要素 */
const mvBackdrop = document.getElementById('mvBackdrop');
const mvCard = document.getElementById('mvCard');
let mvTimer = null;
let mvShowTimer = null;

/* ★ジーザス黒ポップ */
const jesusBackdrop = document.getElementById('jesusBackdrop');
const jesusPop = document.getElementById('jesusPop');

let drawCtx = null;
let drawIsOpen = false;
let drawIsPointerDown = false;
let drawTool = "pen";
let drawCurrentPath = null;
let drawLocalDirty = false;
let drawSyncTimer = null;

let wbLocalTyping = false;
let wbSyncTimer = null;

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;

let isRenderingSeatTabs = false;
let latestPlayers = [];

const ROLE_IMG = {
  MAJORITY: 'majority.jpg',
  MINORITY: 'minority.jpg',
  INFLUENCER: 'influencer.jpg',
  STALKER: 'stalker.jpg',
  JESUS: 'jesus.jpg',
  MENHERA_COUPLE: 'menhera_couple.jpg'
};

const HELP_ROLES = [
  { key:"MAJORITY", name:"マジョリティ", img:"majority.jpg", desc:"最も多い意見をベストアンサーとして採用する。投票でマイノリティを見つけなければならない。ベストアンサーに選ばれたプレイヤーは投票されない。" },
  { key:"MINORITY", name:"マイノリティ", img:"minority.jpg", desc:"投票で自分の正体がばれなければよい。ベストアンサーに選ばれてはいけない。" },
  { key:"INFLUENCER", name:"インフルエンサー", img:"influencer.jpg", desc:"投票で自分に最も票が集まれば、勝ち" },
  { key:"STALKER", name:"ストーカー", img:"stalker.jpg", desc:"マイノリティと同じ意見であれば、単独勝利！" },
  { key:"JESUS", name:"ジーザス", img:"jesus.jpg", desc:"ベストアンサーに選ばれなければ、「ジーザス！」と言って、負けが決まる。" },
  { key:"MENHERA_COUPLE", name:"メンヘラカップル", img:"menhera_couple.jpg", desc:"もう一人のメンヘラカップルを知っている。2人が同じ意見になれれば、マジョリティとして勝利を目指す。意見が異なれば、自分のペアに最多票が集まれば、勝ち" }
];
const FORCE_KEYS = new Set(["INFLUENCER","STALKER","JESUS","MENHERA_COUPLE"]);

/* =========================================================
   投票スキップ（投票相手ゼロなら投票済扱い）
   ========================================================= */
const VOTE_SKIP = "__SKIP__";
const isRealVote = (v) => !!v && v !== VOTE_SKIP;

/* ===========================
   ★人数選択中UI（席ポップ非表示 + 下黒ポップ）
   =========================== */
function updateSeatAndStatusUI(){
  const entered = !!state.roomCode && !joinBox.classList.contains('hidden');
  // joinBox hidden後にenteredになるので、ロビー表示で判断
  const inLobby = !lobby.classList.contains('hidden');

  const maxNotSet = !state.maxPlayers; // null/undefined
  const shouldShowSelecting = inLobby && maxNotSet && !state.isHost;
  statusPop.classList.toggle('hidden', !shouldShowSelecting);

  // 非ホストは、ホストが人数選択中なら seatPop を出さない
  if (inLobby && maxNotSet && !state.isHost){
    seatPop.classList.add('hidden');
    return;
  }

  // maxPlayersが決まっていて、未着席なら seatPop を同期表示
  if (inLobby && !!state.maxPlayers && state.seatedTable === null){
    seatPop.classList.remove('hidden');
  } else {
    // 着席したら消える（同期）
    seatPop.classList.toggle('hidden', state.seatedTable !== null);
  }
}

/* ===========================
   ★ジーザス公開ポップ制御
   =========================== */
function closeJesusPop(){
  jesusBackdrop.classList.add('hidden');
  jesusBackdrop.setAttribute('aria-hidden','true');
}
function openJesusPop(){
  jesusBackdrop.classList.remove('hidden');
  jesusBackdrop.setAttribute('aria-hidden','false');
}
function shouldShowJesusPop(){
  if (!state.roomCode) return false;
  if (state.rolesRevealed) return false;
  if (state.phase !== "VOTE") return false;
  const myRole = state.roles[state.userId]?.role || null;
  if (myRole !== "JESUS") return false;
  if (state.publicReveals && state.publicReveals[state.userId]) return false;
  return true;
}
function syncJesusPopVisibility(){
  if (shouldShowJesusPop()) openJesusPop();
  else closeJesusPop();
}

/* ★ジーザス：クリックで公開＋演出を全員同期 */
jesusPop.addEventListener('click', async () => {
  if (!state.roomCode) return;

  await set(ref(db, `rooms/${state.roomCode}/publicReveals/${state.userId}`), true);
  closeJesusPop();

  await set(ref(db, `rooms/${state.roomCode}/fx`), {
    type: "JESUS_SHAKE",
    playerId: state.userId,
    nonce: Date.now()
  });
});
jesusPop.addEventListener('keydown', async (e) => {
  if (e.key === "Enter" || e.key === " ") {
    e.preventDefault();
    jesusPop.click();
  }
});
jesusBackdrop.addEventListener('click', (e) => { /* 背景クリックは閉じない */ });

/* ===========================
   Help
   =========================== */
function renderHelpList(){
  helpList.innerHTML = "";
  for (const r of HELP_ROLES){
    const row = document.createElement("div");
    row.className = "help-row";

    const img = document.createElement("div");
    img.className = "help-cardimg";
    img.style.backgroundImage = `url('${r.img}')`;

    if (FORCE_KEYS.has(r.key)){
      const on = !!(state.forcedRoles && state.forcedRoles[r.key]);
      img.classList.add(on ? "full" : "dim");
      if (state.isHost){
        img.classList.add("clickable");
        img.onclick = async () => { await toggleForcedRole(r.key); };
      }
    } else {
      img.classList.add("full");
    }

    const desc = document.createElement("div");
    desc.className = "help-desc";
    desc.textContent = `${r.name}：${r.desc}`;

    row.appendChild(img);
    row.appendChild(desc);
    helpList.appendChild(row);
  }
}
function openHelp(){
  renderHelpList();
  helpBackdrop.classList.remove('hidden');
  helpBackdrop.setAttribute('aria-hidden','false');
}
function closeHelp(){
  helpBackdrop.classList.add('hidden');
  helpBackdrop.setAttribute('aria-hidden','true');
}
helpBtn.addEventListener('click', () => openHelp());
helpClose.addEventListener('click', () => closeHelp());
helpBackdrop.addEventListener('click', (e) => { if (e.target === helpBackdrop) closeHelp(); });
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && !helpBackdrop.classList.contains('hidden')) closeHelp();
});

async function toggleForcedRole(roleKey){
  if (!state.isHost) return;
  if (!state.roomCode) return;
  if (!FORCE_KEYS.has(roleKey)) return;
  const p = ref(db, `rooms/${state.roomCode}/forcedRoles/${roleKey}`);
  const cur = !!(state.forcedRoles && state.forcedRoles[roleKey]);
  await set(p, !cur);
}

function subscribeForcedRoles(){
  if (!state.roomCode) return;
  const fr = ref(db, `rooms/${state.roomCode}/forcedRoles`);
  onValue(fr, snap => {
    state.forcedRoles = snap.val() || {};
    if (!helpBackdrop.classList.contains('hidden')) renderHelpList();
  });
}

/* ★追加：個別公開（publicReveals）subscribe */
function subscribePublicReveals(){
  if (!state.roomCode) return;
  const pr = ref(db, `rooms/${state.roomCode}/publicReveals`);
  onValue(pr, snap => {
    state.publicReveals = snap.val() || {};
    syncJesusPopVisibility();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}

/* ★追加：FX同期 subscribe（ジーザス拡大揺れを全員に） */
function subscribeFx(){
  if (!state.roomCode) return;
  const fxRef = ref(db, `rooms/${state.roomCode}/fx`);
  onValue(fxRef, snap => {
    const fx = snap.val();
    if (!fx) return;

    const nonce = fx.nonce || 0;
    if (nonce <= (state._lastFxNonce || 0)) return;
    state._lastFxNonce = nonce;

    if (fx.type === "JESUS_SHAKE" && fx.playerId){
      closeMostVotedOverlay();
      openMostVotedOverlay(fx.playerId);
    }
  });
}

/* ★追加：maxPlayers subscribe（①の同期要） */
function subscribeMaxPlayers(){
  if (!state.roomCode) return;
  const mpRef = ref(db, `rooms/${state.roomCode}/maxPlayers`);
  onValue(mpRef, async snap => {
    state.maxPlayers = snap.val() || null;

    // maxPlayersが決まった瞬間、未着席なら席タブを作り直す（同期）
    if (state.seatedTable === null){
      await renderSeatTabs();
    }
    updateSeatAndStatusUI();
  });
}

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}

async function restoreSeatFromDB(){
  if (!state.roomCode) return;
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  const snap = await get(tablesRef);
  const data = snap.val() || {};
  let mySeatIndex = null;
  for (const [seatIndex, t] of Object.entries(data)) {
    if (t && t.playerId === state.userId) { mySeatIndex = Number(seatIndex); break; }
  }
  if (mySeatIndex !== null) state.seatedTable = mySeatIndex;
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}

function getBestSelectedSet(){
  return new Set(Object.keys(state.bestSelected || {}).filter(k => state.bestSelected[k]));
}
function updateBestAnswerButtonLabel(){
  const s = getBestSelectedSet();
  bestAnswerLabel.textContent = (s.size >= 1) ? "Best Answer!" : "No Best Answer!";
}

function updateVotePopVisibility(){
  const shouldShow = (state.phase === "VOTE" && !state.rolesRevealed);
  votePop.classList.toggle('hidden', !shouldShow);
  if (!shouldShow) return;

  const myVote = state.votes[state.userId];

  if (state.votesDone){
    votePop.querySelector('.desc').innerHTML = '全員の投票が完了しました（結果を表示中）';
  } else if (myVote){
    if (myVote === VOTE_SKIP){
      votePop.querySelector('.desc').innerHTML = '投票相手がいないため、<strong>投票済み扱い</strong>になりました。';
    } else {
      votePop.querySelector('.desc').innerHTML = '投票中：<strong>全員決定までは選び直し可</strong>（投票済みの人は黒く見えます）';
    }
  } else {
    votePop.querySelector('.desc').innerHTML = 'ネームタグを選択（<strong>全員決定までは選び直し可</strong>）';
  }
}

function updateBestAnswerButtonVisibility(){
  const shouldShow =
    state.isHost &&
    !!state.boardsRevealed &&
    !state.rolesRevealed &&
    state.phase !== "VOTE";

  if (shouldShow){
    bestAnswerBtn.classList.add('visible');
    bestAnswerBtn.classList.remove('hidden');
  } else {
    bestAnswerBtn.classList.remove('visible');
    bestAnswerBtn.classList.add('hidden');
  }
  updateBestAnswerButtonLabel();
}

async function toggleBestSelectionSynced(pid){
  if (!state.isHost) return;
  if (!state.boardsRevealed) return;
  if (state.rolesRevealed) return;
  if (state.phase === "VOTE") return;
  const bRef = ref(db, `rooms/${state.roomCode}/bestSelected/${pid}`);
  const cur = !!(state.bestSelected && state.bestSelected[pid]);
  await set(bRef, !cur);
}

function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost){
    hostSettingsBtn.classList.add('visible');
  } else {
    hostSettingsBtn.classList.remove('visible');
    startPop.classList.add('hidden');
  }
  updateBestAnswerButtonVisibility();
  updateVotePopVisibility();
  syncJesusPopVisibility();
  updateSeatAndStatusUI();
}

/* ===========================
   中央拡大カード演出
   =========================== */
function closeMostVotedOverlay(){
  if (mvShowTimer) { clearTimeout(mvShowTimer); mvShowTimer = null; }
  if (mvTimer) { clearTimeout(mvTimer); mvTimer = null; }
  mvBackdrop.classList.add('hidden');
  mvBackdrop.setAttribute('aria-hidden','true');
  mvCard.style.backgroundImage = '';
}
function openMostVotedOverlay(playerId){
  if (!playerId) return;
  const role = state.roles[playerId]?.role;
  const img = ROLE_IMG[role] || null;
  if (!img) return;
  if (mvTimer) clearTimeout(mvTimer);

  mvCard.style.backgroundImage = `url('${img}')`;
  mvBackdrop.classList.remove('hidden');
  mvBackdrop.setAttribute('aria-hidden','false');

  mvTimer = setTimeout(() => { closeMostVotedOverlay(); }, 1400);
}
mvBackdrop.addEventListener('click', (e) => {
  if (e.target === mvBackdrop) closeMostVotedOverlay();
});

function getVoteCounts(){
  const counts = {};
  for (const [, target] of Object.entries(state.votes || {})){
    if (!isRealVote(target)) continue;
    counts[target] = (counts[target] || 0) + 1;
  }
  return counts;
}
function getMostVotedPlayerId(){
  const counts = getVoteCounts();
  let bestId = null;
  let bestCount = -1;
  for (const [pid, c] of Object.entries(counts)){
    if (c > bestCount){
      bestCount = c;
      bestId = pid;
    }
  }
  return bestId;
}
function getMinorityInBestSelected(){
  const s = getBestSelectedSet();
  for (const pid of s){
    if (state.roles[pid]?.role === "MINORITY") return pid;
  }
  return null;
}
function scheduleRevealFX(){
  if (mvShowTimer) { clearTimeout(mvShowTimer); mvShowTimer = null; }
  closeMostVotedOverlay();

  const minorityPid = getMinorityInBestSelected();
  const shouldUseMinority = !!minorityPid;
  const mostVotedPid = getMostVotedPlayerId();
  const targetPid = shouldUseMinority ? minorityPid : mostVotedPid;
  if (!targetPid) return;

  mvShowTimer = setTimeout(() => { openMostVotedOverlay(targetPid); }, 1000);
}

/* ===========================
   Firebase subscribe
   =========================== */
function subscribeHostState(){
  if (!state.roomCode) return;
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    if (!helpBackdrop.classList.contains('hidden')) renderHelpList();
  });
}

function subscribeRoles(){
  if (!state.roomCode) return;
  const rolesRef = ref(db, `rooms/${state.roomCode}/roles`);
  onValue(rolesRef, snap => {
    state.roles = snap.val() || {};
    renderRoles();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
    syncJesusPopVisibility();
  });
}

function subscribeBestSelected(){
  if (!state.roomCode) return;
  const bsRef = ref(db, `rooms/${state.roomCode}/bestSelected`);
  onValue(bsRef, snap => {
    state.bestSelected = snap.val() || {};
    updateBestAnswerButtonVisibility();
    renderRoles();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}

function subscribeVotes(){
  if (!state.roomCode) return;
  const vRef = ref(db, `rooms/${state.roomCode}/votes`);
  onValue(vRef, snap => {
    state.votes = snap.val() || {};
    updateVotePopVisibility();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
    maybeSetVotesDone();
  });
}
function subscribeVotesDone(){
  if (!state.roomCode) return;
  const vd = ref(db, `rooms/${state.roomCode}/votesDone`);
  onValue(vd, snap => {
    state.votesDone = !!snap.val();
    updateVotePopVisibility();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
    maybeAutoRevealRolesAfterVote();
  });
}

function subscribeWhiteboard(){
  if (!state.roomCode) return;
  const wbRef = ref(db, `rooms/${state.roomCode}/whiteboard`);
  onValue(wbRef, snap => {
    const data = snap.val() || { text: "" };
    state.whiteboard = data;
    if (wbLocalTyping) return;
    wbText.textContent = data.text || "";
    fitFontToBox(wbText, 22, 10);
  });
}

function subscribePlayerDraw(){
  if (!state.roomCode) return;
  const pdRef = ref(db, `rooms/${state.roomCode}/playerDraw`);
  onValue(pdRef, snap => {
    state.playerDraw = snap.val() || {};
    renderRoles();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}

function subscribeBoardsRevealed(){
  if (!state.roomCode) return;
  const rRef = ref(db, `rooms/${state.roomCode}/boardsRevealed`);
  onValue(rRef, snap => {
    state.boardsRevealed = !!snap.val();
    updateBestAnswerButtonVisibility();
    renderRoles();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
  });
}

let prevRolesRevealed = false;
function subscribeRolesRevealed(){
  if (!state.roomCode) return;
  const rr = ref(db, `rooms/${state.roomCode}/rolesRevealed`);
  onValue(rr, snap => {
    const v = !!snap.val();
    state.rolesRevealed = v;
    updateBestAnswerButtonVisibility();
    updateVotePopVisibility();
    renderRoles();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);
    syncJesusPopVisibility();

    if (!prevRolesRevealed && v){
      scheduleRevealFX();
    }
    prevRolesRevealed = v;
  });
}

function subscribePhase(){
  if (!state.roomCode) return;
  const pr = ref(db, `rooms/${state.roomCode}/phase`);
  onValue(pr, snap => {
    state.phase = snap.val() || "WRITE";
    updateBestAnswerButtonVisibility();
    updateVotePopVisibility();
    if (latestPlayers.length) renderPlayerCircle(latestPlayers);

    syncJesusPopVisibility();
    maybeAutoRevealRolesAfterVote();
  });
}

async function maybeAutoRevealRolesAfterVote(){
  if (!state.roomCode) return;
  if (!state.isHost) return;
  if (state.phase !== "VOTE") return;
  if (!state.votesDone) return;
  if (state.rolesRevealed) return;

  await update(ref(db, `rooms/${state.roomCode}`), { rolesRevealed:true, phase:"REVEAL" });
}

/* ===========================
   手書き
   =========================== */
function ensureMyDraw(){
  const cur = state.playerDraw[state.userId];
  if (cur && Array.isArray(cur.paths)) return cur;
  return { paths: [], done:false, updatedAt: Date.now(), updatedBy: state.userId };
}
function resizeCanvasToCSS(canvas){
  const rect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const w = Math.max(1, Math.round(rect.width * dpr));
  const h = Math.max(1, Math.round(rect.height * dpr));
  if (canvas.width !== w || canvas.height !== h){
    canvas.width = w;
    canvas.height = h;
  }
}
function clearCanvas(ctx){
  ctx.save();
  ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height);
  ctx.restore();
}
function drawPathsTo(ctx, paths){
  clearCanvas(ctx);
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  for (const p of (paths || [])){
    const pts = p.points || [];
    if (pts.length < 1) continue;
    const size = (p.size || 3);
    ctx.save();
    if (p.tool === "eraser"){
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
    } else {
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = "#111";
    }
    ctx.lineWidth = size;
    ctx.beginPath();
    const x0 = pts[0].x * ctx.canvas.width;
    const y0 = pts[0].y * ctx.canvas.height;
    ctx.moveTo(x0, y0);
    for (let i=1; i<pts.length; i++){
      const x = pts[i].x * ctx.canvas.width;
      const y = pts[i].y * ctx.canvas.height;
      ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.restore();
  }
}
function updateEraserBtnUI(){
  btnEraser.textContent = "";
  btnEraser.classList.toggle("is-eraser", drawTool === "eraser");
  btnEraser.classList.toggle("is-pen",    drawTool !== "eraser");
}
function openDrawModal(){
  if (!state.roomCode) return;
  if (state.boardsRevealed) return;
  drawBackdrop.classList.remove('hidden');
  drawBackdrop.setAttribute('aria-hidden','false');
  drawIsOpen = true;
  if (!drawCtx) drawCtx = drawCanvas.getContext("2d");
  resizeCanvasToCSS(drawCanvas);
  const my = ensureMyDraw();
  drawPathsTo(drawCtx, my.paths);
  drawTool = "pen";
  updateEraserBtnUI();
}
function closeDrawModal(){
  drawBackdrop.classList.add('hidden');
  drawBackdrop.setAttribute('aria-hidden','true');
  drawIsOpen = false;
  drawIsPointerDown = false;
  drawCurrentPath = null;
}
drawBackdrop.addEventListener('click', (e) => { if (e.target === drawBackdrop) closeDrawModal(); });
window.addEventListener('resize', () => {
  if (!drawIsOpen) return;
  if (!drawCtx) return;
  const my = ensureMyDraw();
  resizeCanvasToCSS(drawCanvas);
  drawPathsTo(drawCtx, my.paths);
});
btnEraser.addEventListener('click', () => {
  drawTool = (drawTool === "eraser") ? "pen" : "eraser";
  updateEraserBtnUI();
});
btnUndo.addEventListener('click', async () => {
  if (!state.roomCode) return;
  const cur = ensureMyDraw();
  if (!cur.paths.length) return;
  cur.paths.pop();
  drawPathsTo(drawCtx, cur.paths);
  await syncMyDraw(cur, { force:true });
});
btnDoneDraw.addEventListener('click', async () => {
  if (!state.roomCode) return;
  const cur = ensureMyDraw();
  cur.done = true;
  cur.updatedAt = Date.now();
  cur.updatedBy = state.userId;
  await set(ref(db, `rooms/${state.roomCode}/playerDraw/${state.userId}`), cur);
  closeDrawModal();
  maybeAutoRevealIfAllDone();
});
function getNormPointFromEvent(ev){
  const rect = drawCanvas.getBoundingClientRect();
  const x = (ev.clientX - rect.left) / rect.width;
  const y = (ev.clientY - rect.top) / rect.height;
  return { x: Math.max(0, Math.min(1, x)), y: Math.max(0, Math.min(1, y)) };
}
function startPath(pt){
  const size = (drawTool === "eraser") ? 18 : 3.6;
  drawCurrentPath = { tool: drawTool, size, points: [pt] };
}
function appendPath(pt){
  if (!drawCurrentPath) return;
  drawCurrentPath.points.push(pt);
}
async function commitPath(){
  if (!state.roomCode) return;
  if (!drawCurrentPath) return;
  const cur = ensureMyDraw();
  cur.paths = cur.paths || [];
  cur.paths.push(drawCurrentPath);
  cur.done = false;
  cur.updatedAt = Date.now();
  cur.updatedBy = state.userId;
  drawCurrentPath = null;
  await syncMyDraw(cur, { force:false });
}
async function syncMyDraw(cur, { force }){
  if (!state.roomCode) return;
  drawLocalDirty = true;
  if (drawSyncTimer) clearTimeout(drawSyncTimer);
  const delay = force ? 0 : 140;
  drawSyncTimer = setTimeout(async () => {
    await set(ref(db, `rooms/${state.roomCode}/playerDraw/${state.userId}`), cur);
    drawLocalDirty = false;
  }, delay);
}
function drawStrokeSegment(ctx, path){
  const pts = path.points || [];
  if (pts.length < 2) return;
  ctx.save();
  ctx.lineCap = "round";
  ctx.lineJoin = "round";
  if (path.tool === "eraser"){
    ctx.globalCompositeOperation = "destination-out";
    ctx.strokeStyle = "rgba(0,0,0,1)";
  } else {
    ctx.globalCompositeOperation = "source-over";
    ctx.strokeStyle = "#111";
  }
  ctx.lineWidth = path.size || 3;
  const a = pts[pts.length-2];
  const b = pts[pts.length-1];
  ctx.beginPath();
  ctx.moveTo(a.x * ctx.canvas.width, a.y * ctx.canvas.height);
  ctx.lineTo(b.x * ctx.canvas.width, b.y * ctx.canvas.height);
  ctx.stroke();
  ctx.restore();
}
drawCanvas.addEventListener('pointerdown', async (ev) => {
  if (!drawIsOpen) return;
  drawIsPointerDown = true;
  drawCanvas.setPointerCapture(ev.pointerId);
  const pt = getNormPointFromEvent(ev);
  startPath(pt);
  const cur = ensureMyDraw();
  if (cur.done){
    cur.done = false;
    cur.updatedAt = Date.now();
    cur.updatedBy = state.userId;
    await set(ref(db, `rooms/${state.roomCode}/playerDraw/${state.userId}`), cur);
  }
});
drawCanvas.addEventListener('pointermove', (ev) => {
  if (!drawIsOpen) return;
  if (!drawIsPointerDown) return;
  if (!drawCurrentPath) return;
  const pt = getNormPointFromEvent(ev);
  appendPath(pt);
  drawStrokeSegment(drawCtx, drawCurrentPath);
});
drawCanvas.addEventListener('pointerup', async () => {
  if (!drawIsOpen) return;
  if (!drawIsPointerDown) return;
  drawIsPointerDown = false;
  await commitPath();
});
drawCanvas.addEventListener('pointercancel', async () => {
  if (!drawIsOpen) return;
  drawIsPointerDown = false;
  await commitPath();
});

/* ===========================
   Render
   =========================== */
function renderRoles(){
  myHandEl.innerHTML = '';
  const my = state.roles[state.userId];
  if (!my || !my.role) return;

  const card = document.createElement('div');
  card.className = 'my-card';
  const img = ROLE_IMG[my.role] || ROLE_IMG.MAJORITY;
  card.style.backgroundImage = `url('${img}')`;

  const pboard = document.createElement('div');
  pboard.className = 'pboard';
  pboard.id = 'myPBoard';

  const hint = document.createElement('div');
  hint.className = 'pboard-hint';
  hint.textContent = 'クリックして書く';

  const prev = document.createElement('div');
  prev.className = 'pboard-preview';
  const prevCanvas = document.createElement('canvas');
  prevCanvas.width = 320;
  prevCanvas.height = 220;
  prev.appendChild(prevCanvas);

  pboard.appendChild(hint);
  pboard.appendChild(prev);

  myHandEl.appendChild(card);
  myHandEl.appendChild(pboard);

  const myDraw = ensureMyDraw();
  const isDone = !!myDraw.done;
  const revealed = !!state.boardsRevealed;

  if (!revealed && isDone){
    pboard.classList.add('flipped');
  } else {
    pboard.classList.remove('flipped');
  }

  const ctx = prevCanvas.getContext("2d");
  drawPathsTo(ctx, myDraw.paths || []);

  const selectedSet = getBestSelectedSet();
  if (revealed){
    if (state.isHost && !state.rolesRevealed && state.phase !== "VOTE"){
      pboard.style.cursor = "pointer";
      pboard.onclick = () => toggleBestSelectionSynced(state.userId);
    } else {
      pboard.style.cursor = "";
      pboard.onclick = null;
    }
    pboard.classList.toggle('selected', selectedSet.has(state.userId));
    hint.style.display = 'none';
    return;
  }

  pboard.onclick = () => { openDrawModal(); };
}

function renderPlayerCircle(players){
  const wbNode = document.getElementById('whiteboard');
  playerCircle.innerHTML = '';
  playerCircle.appendChild(wbNode);
  if (!players.length) return;

  const n = players.length;
  const radius = 45;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;

  const meIndex = players.findIndex(p => p.id === state.userId);
  const selectedSet = getBestSelectedSet();

  const votingNow = (state.phase === "VOTE" && !state.rolesRevealed);
  const myVote = state.votes[state.userId] || null;

  if (votingNow && !state.votesDone && !myVote){
    const candidates = players
      .map(p => p.id)
      .filter(pid => pid !== state.userId)
      .filter(pid => !selectedSet.has(pid));
    if (candidates.length === 0){
      set(ref(db, `rooms/${state.roomCode}/votes/${state.userId}`), VOTE_SKIP);
    }
  }

  const counts = {};
  if (state.votesDone){
    for (const [, target] of Object.entries(state.votes || {})){
      if (!isRealVote(target)) continue;
      counts[target] = (counts[target] || 0) + 1;
    }
  }

  const myRole = state.roles[state.userId]?.role || null;
  const iAmMenhera = (myRole === "MENHERA_COUPLE");

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top = `${y}%`;

    const isBlueSelected = selectedSet.has(p.id);
    if (votingNow && isBlueSelected) tag.classList.add('unvotable');

    if (myVote){
      const otherVoted = !!state.votes[p.id];
      if (p.id !== state.userId && otherVoted) tag.classList.add('voted');
    }

    if (votingNow && !state.votesDone && myVote && myVote === p.id){
      const b = document.createElement('div');
      b.className = 'vote-badge';
      b.textContent = '✉';
      tag.appendChild(b);
    }

    if (votingNow && state.votesDone){
      const c = counts[p.id] || 0;
      if (c > 0){
        const b = document.createElement('div');
        b.className = 'vote-badge';
        b.textContent = (c <= 10) ? '✉'.repeat(c) : ('✉'.repeat(10) + `+${c-10}`);
        tag.appendChild(b);
      }
    }

    tag.onclick = () => {
      if (votingNow){
        if (!state.roomCode) return;
        if (!state.seatedTable) return;
        if (state.votesDone) return;
        if (p.id === state.userId) return;
        if (selectedSet.has(p.id)) return;
        castVote(p.id);
        return;
      }

      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;

      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;

      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

    if (votingNow && !state.votesDone && p.id !== state.userId && !selectedSet.has(p.id)){
      tag.classList.add('votable');
      tag.style.cursor = "pointer";
    } else if (votingNow){
      tag.style.cursor = selectedSet.has(p.id) ? "not-allowed" : "";
    } else {
      tag.style.cursor = "";
    }

    const revealed = !!state.boardsRevealed;
    const isOther = (p.id !== state.userId);

    const d = state.playerDraw[p.id] || { paths:[], done:false };
    const done = !!d.done;
    tag.classList.toggle('done', done);

    if (isOther){
      if (revealed){
        const box = document.createElement('div');
        box.className = 'mini-pboard revealed';

        const c = document.createElement('canvas');
        c.className = 'mini-pboard-canvas';
        c.width = 146;
        c.height = 104;
        box.appendChild(c);

        const ctx = c.getContext("2d");
        drawPathsTo(ctx, d.paths || []);

        if (state.isHost && !state.rolesRevealed && state.phase !== "VOTE"){
          box.classList.add('selectable');
          box.onclick = (e) => {
            e.stopPropagation();
            toggleBestSelectionSynced(p.id);
          };
        }
        box.classList.toggle('selected', selectedSet.has(p.id));
        tag.appendChild(box);
      } else {
        if (done){
          const box = document.createElement('div');
          box.className = 'mini-pboard';
          tag.appendChild(box);
        }
      }
    }

    if (isOther){
      const miniWrap = document.createElement('div');
      miniWrap.className = 'mini-role';

      const mini = document.createElement('div');
      mini.className = 'mini-card';

      const otherRole = state.roles[p.id]?.role || null;

      const miniFaceUpCommon =
        state.rolesRevealed || (state.phase === "VOTE" && state.votesDone);

      const miniFaceUpMenheraPair =
        iAmMenhera && (p.id !== state.userId) && (otherRole === "MENHERA_COUPLE");

      const miniFaceUpPublic =
        !!(state.publicReveals && state.publicReveals[p.id]);

      const miniFaceUp = miniFaceUpCommon || miniFaceUpMenheraPair || miniFaceUpPublic;

      if (miniFaceUp){
        mini.classList.add('role-revealed');
        const img = ROLE_IMG[otherRole] || "";
        mini.textContent = '';
        mini.style.backgroundImage = img ? `url('${img}')` : '';
      } else {
        mini.textContent = '';
        mini.classList.remove('role-revealed');
        mini.style.backgroundImage = `url('mymajo.jpg')`;
      }

      miniWrap.appendChild(mini);
      tag.appendChild(miniWrap);
    }

    playerCircle.appendChild(tag);
  });
}

/* ===========================
   Vote logic
   =========================== */
async function castVote(targetId){
  if (!state.roomCode) return;
  if (state.votesDone) return;
  const selectedSet = getBestSelectedSet();
  if (selectedSet.has(targetId)) return;
  await set(ref(db, `rooms/${state.roomCode}/votes/${state.userId}`), targetId);
}

async function maybeSetVotesDone(){
  if (!state.roomCode) return;
  if (state.votesDone) return;
  if (state.phase !== "VOTE") return;
  if (!latestPlayers.length) return;

  const ids = latestPlayers.map(p => p.id);
  if (ids.length < 2) return;

  const allVoted = ids.every(pid => !!state.votes[pid]);
  if (!allVoted) return;

  await update(ref(db, `rooms/${state.roomCode}`), { votesDone: true });
}

/* ===========================
   Join / Seat / Kick
   =========================== */
const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  // 初期値（足りないものだけ）
  if (!roomData || roomData.boardsRevealed == null) await update(roomRef, { boardsRevealed:false });
  if (!roomData || roomData.rolesRevealed == null) await update(roomRef, { rolesRevealed:false });
  if (!roomData || roomData.phase == null) await update(roomRef, { phase:"WRITE" });
  if (!roomData || roomData.votesDone == null) await update(roomRef, { votesDone:false });
  if (!roomData || roomData.forcedRoles == null) await update(roomRef, { forcedRoles: {} });
  if (!roomData || roomData.playerDraw == null) await update(roomRef, { playerDraw: {} });
  if (!roomData || roomData.publicReveals == null) await update(roomRef, { publicReveals: {} });
  if (!roomData || roomData.fx == null) await update(roomRef, { fx: null });

  // maxPlayersは「未設定＝人数選択中」を表現
  if (!roomData || roomData.maxPlayers == null) await update(roomRef, { maxPlayers: null });

  updateHostUI();

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');
  document.querySelector('main').classList.add('entered');

  helpBtn.classList.add('visible');

  await restoreSeatFromDB();

  // ここで maxPlayers は subscribeで同期される
  await renderSeatTabs();
  updateSeatAndStatusUI();

  subscribePlayers();
  subscribeHostState();
  subscribeMaxPlayers();      // ★追加
  subscribeRoles();
  subscribeWhiteboard();
  subscribeBoardsRevealed();
  subscribeBestSelected();
  subscribeVotes();
  subscribeVotesDone();
  subscribeRolesRevealed();
  subscribePhase();
  subscribeForcedRoles();
  subscribePlayerDraw();
  subscribePublicReveals();
  subscribeFx();

  const myDRef = ref(db, `rooms/${state.roomCode}/playerDraw/${state.userId}`);
  const myDSnap = await get(myDRef);
  if (!myDSnap.exists()){
    await set(myDRef, { paths: [], done:false, updatedAt: Date.now(), updatedBy: state.userId });
  }
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='COPY';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

/* ===========================
   ★席/人数タブ描画（①）
   - maxPlayers未設定:
     - ホスト: 人数選択タブ（2..8）
     - 非ホスト: 何も出さない（下黒ポップのみ）
   - maxPlayers設定済:
     - 席選択タブ（1..maxPlayers）
   =========================== */
async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;
  try {
    seatTabs.innerHTML = '';
    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    state.maxPlayers = maxPlayers;

    // 非ホストで人数未決定なら、seatPop自体を出さない（下黒ポップへ）
    if (!maxPlayers && !state.isHost){
      seatLabel.textContent = '席を選択';
      return;
    }

    if (state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;
        tab.onclick = async () => {
          // maxPlayers確定 + ホストを席1へ
          await update(roomRef, { maxPlayers: i });

          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;

          // 同期で全員のUIが切り替わる
          await renderSeatTabs();
          updateSeatAndStatusUI();
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    // maxPlayers決定後：席選択
    seatLabel.textContent = '席を選択';
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};
    for(let i=1; i<=maxPlayers; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;
      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');
      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName });
        tab.classList.add('disabled');
        state.seatedTable = i;
        updateSeatAndStatusUI();
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

/* ===========================
   ★席同期（①）
   =========================== */
function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
      seatPop.classList.remove('hidden');
    }

    // ★追加：未着席で席ポップが出ているなら、tabsを再描画して空き状況を同期
    if (state.seatedTable === null && !seatPop.classList.contains('hidden')) {
      await renderSeatTabs(); // isRenderingSeatTabs があるので連打されても安全
    }

    renderPlayerCircle(players);
    maybeSetVotesDone();
  });
}


/* ===========================
   ★席奪取（③）引き継ぎ
   - oldPid の「正体/ボード/投票/公開/ベスト選択」を newUid に移管
   - さらに「他人の投票先/ベスト選択先」も oldPid→newUid に置換
   =========================== */
async function stealSeatWithInheritance(seatIndex, oldPid){
  if (!state.roomCode) return;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const snap = await get(roomRef);
  const room = snap.val() || {};

  const roles = room.roles || {};
  const playerDraw = room.playerDraw || {};
  const votes = room.votes || {};
  const publicReveals = room.publicReveals || {};
  const bestSelected = room.bestSelected || {};
  const hostId = room.hostId || null;

  const updates = {};
  const base = `rooms/${state.roomCode}`;

  // 1) 席の入れ替え
  updates[`${base}/tables/${seatIndex}`] = { playerId: state.userId, playerName: state.userName || '名無し' };

  // 2) 旧プレイヤーの「自分の状態」を新プレイヤーへ移管（存在するものだけ）
  if (roles[oldPid]) {
    updates[`${base}/roles/${state.userId}`] = roles[oldPid];
    updates[`${base}/roles/${oldPid}`] = null;
  }
  if (playerDraw[oldPid]) {
    updates[`${base}/playerDraw/${state.userId}`] = playerDraw[oldPid];
    updates[`${base}/playerDraw/${oldPid}`] = null;
  }
  if (votes[oldPid]) {
    updates[`${base}/votes/${state.userId}`] = votes[oldPid];
    updates[`${base}/votes/${oldPid}`] = null;
  }
  if (publicReveals[oldPid]) {
    updates[`${base}/publicReveals/${state.userId}`] = publicReveals[oldPid];
    updates[`${base}/publicReveals/${oldPid}`] = null;
  }
  if (bestSelected[oldPid] != null) {
    updates[`${base}/bestSelected/${state.userId}`] = bestSelected[oldPid];
    updates[`${base}/bestSelected/${oldPid}`] = null;
  }

  // 3) 他人の「投票先」を oldPid→newUid に置換（投票状況も引き継ぐ）
  for (const [voter, target] of Object.entries(votes)){
    if (target === oldPid){
      updates[`${base}/votes/${voter}`] = state.userId;
    }
  }

  // 4) host奪取ならホスト移譲
  if (hostId && hostId === oldPid){
    updates[`${base}/hostId`] = state.userId;
  }

  await update(ref(db), updates);
}

kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const oldPid = pendingSeatPlayerIdToSteal;

  // ★③ 引き継ぎ付き奪取
  await stealSeatWithInheritance(seatIndex, oldPid);

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  updateSeatAndStatusUI();
});

/* ===========================
   Game start
   =========================== */
function shuffle(arr){
  for(let i=arr.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [arr[i],arr[j]] = [arr[j],arr[i]];
  }
  return arr;
}

async function dealIdentityCards(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};
  const playerIds = [];
  for (const seatIndex of Object.keys(tables)) {
    const t = tables[seatIndex];
    if (!t || !t.playerId) continue;
    playerIds.push(t.playerId);
  }
  if (playerIds.length < 2) return;

  const frSnap = await get(ref(db, `rooms/${state.roomCode}/forcedRoles`));
  const forced = frSnap.val() || {};

  const roles = {};
  playerIds.forEach(pid => roles[pid] = { role: "MAJORITY" });

  const forcedList = [];
  if (forced.INFLUENCER) forcedList.push("INFLUENCER");
  if (forced.STALKER) forcedList.push("STALKER");
  if (forced.JESUS) forcedList.push("JESUS");
  if (forced.MENHERA_COUPLE){
    forcedList.push("MENHERA_COUPLE");
    forcedList.push("MENHERA_COUPLE");
  }

  const pool = shuffle([...playerIds]);

  for (const rk of forcedList){
    const target = pool.find(pid => roles[pid].role === "MAJORITY");
    if (!target) break;
    roles[target] = { role: rk };
  }

  const minorityTarget = pool.find(pid => roles[pid].role === "MAJORITY");
  if (minorityTarget){
    roles[minorityTarget] = { role: "MINORITY" };
  } else {
    roles[pool[0]] = { role: "MINORITY" };
  }

  const drawReset = {};
  playerIds.forEach(pid => {
    drawReset[pid] = { paths: [], done:false, updatedAt: Date.now(), updatedBy: state.userId };
  });

  closeMostVotedOverlay();
  closeJesusPop();

  await update(ref(db, `rooms/${state.roomCode}`), {
    boardsRevealed:false,
    rolesRevealed:false,
    phase:"WRITE",
    votesDone:false
  });
  await set(ref(db, `rooms/${state.roomCode}/votes`), {});
  await set(ref(db, `rooms/${state.roomCode}/bestSelected`), {});
  await set(ref(db, `rooms/${state.roomCode}/playerDraw`), drawReset);
  await set(ref(db, `rooms/${state.roomCode}/publicReveals`), {});
  await set(ref(db, `rooms/${state.roomCode}/fx`), null);
  await set(ref(db, `rooms/${state.roomCode}/roles`), roles);
}

/* ===========================
   ★設定（② リセット追加）
   - リセットでカード/ボード/投票/公開/席を初期化し「席選択（人数選択）」へ戻す
   =========================== */
async function hardResetRoomToSeatSelect(){
  if (!state.isHost) return;
  if (!state.roomCode) return;

  const base = `rooms/${state.roomCode}`;
  const updates = {};

  // ゲーム状態リセット
  updates[`${base}/boardsRevealed`] = false;
  updates[`${base}/rolesRevealed`] = false;
  updates[`${base}/phase`] = "WRITE";
  updates[`${base}/votesDone`] = false;

  // データクリア
  updates[`${base}/roles`] = {};
  updates[`${base}/votes`] = {};
  updates[`${base}/bestSelected`] = {};
  updates[`${base}/playerDraw`] = {};
  updates[`${base}/publicReveals`] = {};
  updates[`${base}/fx`] = null;
  updates[`${base}/whiteboard`] = { text:"", updatedAt: Date.now(), updatedBy: state.userId };

  // ★席選択へ戻す：テーブル全消去 & 人数未設定に戻す（人数選択から）
  updates[`${base}/tables`] = {};
  updates[`${base}/maxPlayers`] = null;

  await update(ref(db), updates);

  // ローカルも戻す（同期でも追従するが即反映）
  state.seatedTable = null;
  state.maxPlayers = null;
  await renderSeatTabs();
  updateSeatAndStatusUI();
}

hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => { startPop.classList.add('hidden'); });

btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await dealIdentityCards();
  startPop.classList.add('hidden');
});

btnRoomReset.addEventListener('click', async () => {
  if (!state.isHost) return;
  await hardResetRoomToSeatSelect();
  startPop.classList.add('hidden');
});

/* ===========================
   Best Answer / No Best Answer
   =========================== */
bestAnswerBtn.addEventListener('click', async () => {
  if (!state.isHost) return;
  if (!state.roomCode) return;
  if (!state.boardsRevealed) return;
  if (state.rolesRevealed) return;
  if (state.phase === "VOTE") return;

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const selectedSet = getBestSelectedSet();

  if (selectedSet.size === 0){
    await update(roomRef, { rolesRevealed: true, phase: "REVEAL" });
    return;
  }

  let hasMinority = false;
  for (const pid of selectedSet){
    const r = state.roles[pid]?.role;
    if (r === 'MINORITY'){ hasMinority = true; break; }
  }

  if (hasMinority){
    await update(roomRef, { rolesRevealed: true, phase: "REVEAL" });
  } else {
    await update(roomRef, { phase: "VOTE", votesDone:false });
    await set(ref(db, `rooms/${state.roomCode}/votes`), {});
  }
});

/* ===========================
   中央ホワイトボード：同期
   =========================== */
function scheduleWhiteboardSync(){
  if (!state.roomCode) return;
  if (wbSyncTimer) clearTimeout(wbSyncTimer);
  wbSyncTimer = setTimeout(async () => {
    const text = wbText.textContent || "";
    await set(ref(db, `rooms/${state.roomCode}/whiteboard`), {
      text,
      updatedAt: Date.now(),
      updatedBy: state.userId
    });
  }, 120);
}

wb.addEventListener('click', () => {
  wbText.contentEditable = "true";
  wbText.focus();
  placeCaretToEnd(wbText);
});
wbText.addEventListener('focus', () => { wbLocalTyping = true; });
wbText.addEventListener('blur',  () => { wbLocalTyping = false; });

wbText.addEventListener('input', () => {
  fitFontToBox(wbText, 22, 10);
  scheduleWhiteboardSync();
});

wbText.contentEditable = "false";
wbText.textContent = "";
fitFontToBox(wbText, 22, 10);

/* ===========================
   全員完了 → 公開
   =========================== */
async function maybeAutoRevealIfAllDone(){
  if (!state.roomCode) return;
  if (state.boardsRevealed) return;
  if (!latestPlayers.length) return;
  if (!Object.keys(state.roles || {}).length) return;

  const ids = latestPlayers.map(p => p.id);
  if (ids.length < 2) return;

  const allDone = ids.every(pid => !!(state.playerDraw[pid] && state.playerDraw[pid].done));
  if (!allDone) return;

  const revealRef = ref(db, `rooms/${state.roomCode}/boardsRevealed`);
  await runTransaction(revealRef, (current) => {
    if (current === true) return current;
    return true;
  });
}

/* ===========================
   Utils
   =========================== */
function placeCaretToEnd(el){
  try{
    const sel = window.getSelection();
    const range = document.createRange();
    range.selectNodeContents(el);
    range.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range);
  }catch{}
}

function fitFontToBox(el, startSize=22, minSize=10){
  let size = startSize;
  el.style.fontSize = size + 'px';
  const maxW = el.clientWidth;
  const maxH = el.clientHeight;

  for(let i=0; i<40; i++){
    const tooWide = el.scrollWidth > maxW + 1;
    const tooTall = el.scrollHeight > maxH + 1;
    if (!tooWide && !tooTall) break;
    size--;
    if (size <= minSize) { size = minSize; break; }
    el.style.fontSize = size + 'px';
  }
}
</script>
</body>
</html>

